WEBVTT
Kind: captions
Language: zh-CN

00:00:00.000 --> 00:00:02.924
我们还需要调整 Wx

00:00:02.924 --> 00:00:07.849
这个权重矩阵连接了输入层和隐藏层或状态层

00:00:07.849 --> 00:00:12.324
我们来简化概略图 只留下我们需要的内容

00:00:12.324 --> 00:00:16.679
你会发现我们调整 Wx 的过程

00:00:16.679 --> 00:00:21.164
与更新 Ws 时的过程非常相似

00:00:21.164 --> 00:00:25.230
话虽如此 我们还是要具体探究这个过程

00:00:25.230 --> 00:00:28.710
如果我们观察时间步长 t 等于 3

00:00:28.710 --> 00:00:33.750
矩阵 Wx 的误差不仅取决于

00:00:33.750 --> 00:00:40.920
向量 S3 还取决于 S2 和之前的 S1

00:00:40.920 --> 00:00:46.285
这些都受到矩阵 Wx 的影响

00:00:46.284 --> 00:00:53.154
乍一看 我们只需要考虑向量 S3

00:00:53.155 --> 00:00:56.910
这样 t 等于 3 时间步长的导数

00:00:56.909 --> 00:00:59.250
通过使用链式法则

00:00:59.250 --> 00:01:03.480
等于输出 y3 平方差的偏导数

00:01:03.479 --> 00:01:11.129
乘以 S3 输出的导数

00:01:11.129 --> 00:01:18.784
最后乘以权重矩阵 Wx S3 的导数

00:01:18.784 --> 00:01:23.109
正如我们之前所说 我们要回顾一下

00:01:23.109 --> 00:01:28.799
S3 也取决于 S2 和 S1

00:01:28.799 --> 00:01:33.384
这些都受到矩阵 Wx 的影响

00:01:33.385 --> 00:01:36.930
那么我们要找的梯度不仅是

00:01:36.930 --> 00:01:40.680
刚才看到三个导数的乘积

00:01:40.680 --> 00:01:42.720
而且是

00:01:42.719 --> 00:01:48.015
之前每个状态贡献的总和

00:01:48.015 --> 00:01:52.039
我们要考虑之前的状态 S2

00:01:52.039 --> 00:01:55.427
再次通过使用链式法则

00:01:55.427 --> 00:01:58.770
我们可以发现下列路径

00:01:58.769 --> 00:02:04.125
可以得到整体梯度的其他贡献

00:02:04.125 --> 00:02:06.629
不过我们并没结束

00:02:06.629 --> 00:02:10.207
我们还要考虑一个状态 S1

00:02:10.207 --> 00:02:15.074
我们会把它的贡献添加到整个累加梯度中

00:02:15.074 --> 00:02:20.122
从输出开始 反向传播到第一个状态

00:02:20.122 --> 00:02:28.185
我们会把下面的其他部分添加到整体梯度中

00:02:28.185 --> 00:02:32.890
我们使用基于时间的反向传播算法 再次观察累加梯度

00:02:32.889 --> 00:02:38.125
即我们要考虑所有的状态向量

00:02:38.125 --> 00:02:43.000
状态 S3 S2 和 S1 计算后的结果

00:02:43.000 --> 00:02:51.500
这是为了正确更新矩阵 Wx 需要的完整梯度

00:02:51.500 --> 00:02:57.330
一般来说 我们需要考虑之前的多个时间步长

00:02:57.330 --> 00:03:01.260
 而不只是这个例子中的三个时间步长 需要通用框架

00:03:01.259 --> 00:03:07.049
定义基于时间的反向传播算法 从而更新 Wx

