WEBVTT
Kind: captions
Language: zh-CN

00:00:00.000 --> 00:00:03.384
我们首先观察前馈部分

00:00:03.384 --> 00:00:05.710
为了让计算更加简单

00:00:05.710 --> 00:00:08.279
我们确定使用 n 个输入

00:00:08.279 --> 00:00:13.179
一个隐藏层的 3 个神经元和 2 个输出

00:00:13.179 --> 00:00:14.980
顺便说一下 实际上

00:00:14.980 --> 00:00:18.780
在单个隐藏层中可能有数千个神经元

00:00:18.780 --> 00:00:22.765
我们使用 W1 作为 x 到 h 的一组权重

00:00:22.765 --> 00:00:27.550
W2 作为 h 到 y 的一组权重

00:00:27.550 --> 00:00:29.905
由于只有一个单独的隐藏层

00:00:29.905 --> 00:00:34.510
所以在每个前馈循环中只有两个步骤

00:00:34.509 --> 00:00:41.259
第一步我们要从特定输入和一组权重 W1 中找出 h

00:00:41.259 --> 00:00:44.964
第二步我们要从计算后的 h

00:00:44.965 --> 00:00:50.225
和一组权重 W2 中找出输出 y

00:00:50.225 --> 00:00:55.170
你会发现除了使用非线性激活函数

00:00:55.170 --> 00:00:57.039
我很快要探讨的内容

00:00:57.039 --> 00:01:02.609
所有计算都涉及输入和权重的线性组合

00:01:02.609 --> 00:01:07.484
换句话说 我们使用矩阵乘法

00:01:07.484 --> 00:01:09.504
首先我们进行第一步 找到 h

00:01:09.504 --> 00:01:15.114
注意如果我们隐藏层包括多个神经元

00:01:15.114 --> 00:01:16.729
通常情况都是如此

00:01:16.730 --> 00:01:19.204
实际上 h 是一个向量

00:01:19.203 --> 00:01:21.954
我们有初始输入 x

00:01:21.954 --> 00:01:24.054
x 也是向量

00:01:24.055 --> 00:01:27.325
我们想要找出隐藏神经元的值 h

00:01:27.325 --> 00:01:32.870
每个输入都连接到隐藏层的每个神经元

00:01:32.870 --> 00:01:40.445
为简单起见 我们使用以下指数 W11 连接 x1 和 h1

00:01:40.444 --> 00:01:44.264
W13 连接 x1 和 h3

00:01:44.265 --> 00:01:48.775
W21 连接 x2 和 h1

00:01:48.775 --> 00:01:55.540
Wn3 连接 xn 和 h3 等等

00:01:55.540 --> 00:02:00.565
输入向量 x1 x2

00:02:00.564 --> 00:02:02.545
直到 xn

00:02:02.545 --> 00:02:09.448
乘以权重矩阵 W1 得到隐藏神经元

00:02:09.448 --> 00:02:11.989
那么每个向量 h’

00:02:11.989 --> 00:02:17.849
等于向量 x’ 乘以权重矩阵 W1

00:02:17.849 --> 00:02:21.745
在这种情况下 因为有 n 个输入

00:02:21.745 --> 00:02:24.009
我们得到 n 行的权重矩阵

00:02:24.009 --> 00:02:29.019
因为隐藏层包括 3 个神经元 我们得到三列

00:02:29.020 --> 00:02:32.650
如果把输入向量乘以权重矩阵

00:02:32.650 --> 00:02:35.455
你会得到隐藏层中每个单元的简单线性组合

00:02:35.455 --> 00:02:39.219
从而得到向量 h’

00:02:39.219 --> 00:02:42.125
那么例如

00:02:42.125 --> 00:02:46.750
h’1 等于 x1 乘以 W11

00:02:46.750 --> 00:02:51.219
加上 x2 乘以 W21 等等

00:02:51.219 --> 00:02:55.509
但是我们还没有完成隐藏层的计算

00:02:55.509 --> 00:02:58.359
注意到我一直使用的上撇号吗？

00:02:58.360 --> 00:03:02.275
我用这个符号提醒 我们还没找到 h

00:03:02.275 --> 00:03:05.140
非常接近却没有完成

00:03:05.139 --> 00:03:10.799
为了避免 h 的值激增或增长过大

00:03:10.800 --> 00:03:16.555
我们需要使用激活函数 通常使用希腊字母 φ

00:03:16.555 --> 00:03:19.300
我们可以使用双曲正切

00:03:19.300 --> 00:03:26.010
使用这个函数可以确保我们的输出在 1 到 -1 之间

00:03:26.009 --> 00:03:28.120
我们也可以使用 sigmoid

00:03:28.120 --> 00:03:33.879
使用这个函数可以确保我们的输出在 0 到 1 之间

00:03:33.879 --> 00:03:38.710
我们也可以使用修正线性单元 即 ReLu 函数

00:03:38.710 --> 00:03:44.400
其中负值为0 正值保持不变

00:03:44.400 --> 00:03:50.310
每个激活函数都存在优缺点

00:03:50.310 --> 00:03:54.215
他们的共同之处是能让网络

00:03:54.215 --> 00:03:58.659
体现出输入和输出的非线性关系

00:03:58.659 --> 00:04:04.875
这是非常重要的 因为现实世界中大部分数据是非线性的

00:04:04.875 --> 00:04:12.789
从数学角度来说 线性组合和激活函数可以简单地写成

00:04:12.789 --> 00:04:16.389
h 等于输入向量乘以对应权重矩阵的

00:04:16.389 --> 00:04:21.689
激活函数的输出结果 即 h = φ (x, W1)

00:04:21.689 --> 00:04:25.379
使用这些函数可能会有点棘手

00:04:25.379 --> 00:04:29.475
因为它们存在之前提到过的梯度消失问题

00:04:29.475 --> 00:04:32.000
不过随后会进行详细介绍

